<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.40">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>2&nbsp; Models ‚Äì Efficient Machine Learning with R</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
/* CSS for citations */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
  margin-bottom: 0em;
}
.hanging-indent div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<link href="./parallelism.html" rel="next">
<link href="./intro.html" rel="prev">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting-549806ee2085284f45b00abea8c6df48.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap-7389bebff3337cfdef73eab9dd25d937.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<meta name="shinylive:serviceworker_dir" content=".">
<script src="site_libs/quarto-contrib/shinylive-0.9.1/shinylive/load-shinylive-sw.js" type="module"></script>
<script src="site_libs/quarto-contrib/shinylive-0.9.1/shinylive/run-python-blocks.js" type="module"></script>
<link href="site_libs/quarto-contrib/shinylive-0.9.1/shinylive/shinylive.css" rel="stylesheet">
<link href="site_libs/quarto-contrib/shinylive-quarto-css/shinylive-quarto.css" rel="stylesheet">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<script async="" src="https://www.googletagmanager.com/gtag/js?id=G-C5VQ0DLJJW"></script>

<script type="text/javascript">

window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-C5VQ0DLJJW', { 'anonymize_ip': true});
</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="nav-sidebar floating">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" role="button" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="./models.html">Fundamentals</a></li><li class="breadcrumb-item"><a href="./models.html"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">Models</span></a></li></ol></nav>
        <a class="flex-grow-1" role="navigation" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
      <button type="button" class="btn quarto-search-button" aria-label="Search" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header">
    <div class="sidebar-title mb-0 py-0">
      <a href="./">Efficient Machine Learning with R</a> 
        <div class="sidebar-tools-main">
    <a href="https://github.com/simonpcouch/emlwr" title="Source Code" class="quarto-navigation-tool px-1" aria-label="Source Code"><i class="bi bi-github"></i></a>
</div>
    </div>
      </div>
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Search"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Welcomeüêõ</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./intro.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">Introduction</span></span></a>
  </div>
</li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" role="navigation" aria-expanded="true">
 <span class="menu-text">Fundamentals</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-1" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./models.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">Models</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./parallelism.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Parallel computing</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./search.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">Search</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./submodel.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">The submodel trick</span></span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-2" role="navigation" aria-expanded="true">
 <span class="menu-text">Beyond the Basics</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-2" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-2" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./preprocessing.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">6</span>&nbsp; <span class="chapter-title">Preprocessing</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./sparsity.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">7</span>&nbsp; <span class="chapter-title">Sparsity</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./stacking.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">8</span>&nbsp; <span class="chapter-title">Stacking</span></span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./references.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">References</span></a>
  </div>
</li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Table of contents</h2>
   
  <ul>
  <li><a href="#sec-models-overhead" id="toc-sec-models-overhead" class="nav-link active" data-scroll-target="#sec-models-overhead"><span class="header-section-number">2.1</span> Tidymodels overhead</a></li>
  <li><a href="#sec-models-benchmarks" id="toc-sec-models-benchmarks" class="nav-link" data-scroll-target="#sec-models-benchmarks"><span class="header-section-number">2.2</span> Benchmarks</a>
  <ul class="collapse">
  <li><a href="#sec-models-one-data-point" id="toc-sec-models-one-data-point" class="nav-link" data-scroll-target="#sec-models-one-data-point"><span class="header-section-number">2.2.1</span> One data point</a></li>
  <li><a href="#why-not-just-model-fits" id="toc-why-not-just-model-fits" class="nav-link" data-scroll-target="#why-not-just-model-fits"><span class="header-section-number">2.2.2</span> Why not just model fits?</a></li>
  <li><a href="#sec-models-analysis" id="toc-sec-models-analysis" class="nav-link" data-scroll-target="#sec-models-analysis"><span class="header-section-number">2.2.3</span> Analysis</a></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default"><nav class="quarto-page-breadcrumbs quarto-title-breadcrumbs d-none d-lg-block" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="./models.html">Fundamentals</a></li><li class="breadcrumb-item"><a href="./models.html"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">Models</span></a></li></ol></nav>
<div class="quarto-title">
<h1 class="title"><span id="sec-models" class="quarto-section-identifier"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">Models</span></span></h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<div class="callout callout-style-default callout-caution callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Caution
</div>
</div>
<div class="callout-body-container callout-body">
<p>This chapter is under active construction! You may be better off checking out other chapters in the meantime.</p>
</div>
</div>
<p>At a high level, this chapter aims to help readers build intuition about how long various model types and engines take to fit. Our first order of business, in <a href="#sec-models-overhead" class="quarto-xref"><span>Section 2.1</span></a>, is demonstrating that fitting a model with tidymodels doesn‚Äôt take much longer than it would to fit the model without tidymodels‚Äô unifying interface on top. That is, if I‚Äôd like to fit a boosted tree with XGBoost, will <code>xgboost::xgb.train()</code> fit notably more quickly than the analogous tidymodels interface <code>boost_tree(engine = "xgboost")</code>? Then, once you‚Äôre convinced the penalty in performance is negligible, we‚Äôll move on to comparing fit times across modeling engines in <a href="#sec-models-benchmarks" class="quarto-xref"><span>Section 2.2</span></a>. That is, does <code>boost_tree(engine = "lightgbm")</code> fit more quickly than <code>boost_tree(engine = "xgboost")</code>?</p>
<section id="sec-models-overhead" class="level2" data-number="2.1">
<h2 data-number="2.1" class="anchored" data-anchor-id="sec-models-overhead"><span class="header-section-number">2.1</span> Tidymodels overhead</h2>
<p>While the tidymodels team develops the infrastructure that users interact with directly, under the hood, we send calls out to other people‚Äôs modeling packages‚Äîor modeling <em>engines</em>‚Äîthat provide the actual implementations that estimate parameters, generate predictions, etc. The process looks something like this:</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="figures/translate_diagram.png" class="img-fluid figure-img"></p>
<figcaption>A graphic representing the tidymodels interface. In order, step 1 ‚Äútranslate‚Äù, step 2 ‚Äúcall‚Äù, and step 3 ‚Äútranslate‚Äù, outline the process of translating from the standardized tidymodels interface to an engine‚Äôs specific interface, calling the modeling engine, and translating back to the standardized tidymodels interface. Step 1 and step 3 are in green, while step 2 is in orange.</figcaption>
</figure>
</div>
<p>When thinking about the time allotted to each of the three steps above, we refer to the ‚Äútranslate‚Äù steps in green as the <em>tidymodels overhead</em>. The time it takes to ‚Äútranslate‚Äù interfaces in steps <strong>1)</strong> and <strong>3)</strong> is within our control, while the time the modeling engine takes to do its thing in step <strong>2)</strong> is not.</p>
<p>Let‚Äôs demonstrate with an example classification problem. Generating some data:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">1</span>)</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>d <span class="ot">&lt;-</span> <span class="fu">simulate_classification</span>(<span class="at">n_rows =</span> <span class="dv">100</span>)</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>d</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code># A tibble: 100 √ó 18
   class   two_factor_1 two_factor_2 non_linear_1 non_linear_2 non_linear_3
   &lt;fct&gt;   &lt;fct&gt;               &lt;dbl&gt; &lt;fct&gt;               &lt;dbl&gt;        &lt;dbl&gt;
 1 class_2 level_1          -1.17    level_1             0.554        0.814
 2 class_1 level_1           0.261   level_2             0.688        0.929
 3 class_2 level_1          -1.61    level_1             0.658        0.147
 4 class_1 level_1           2.14    level_1             0.663        0.750
 5 class_2 level_1           0.0360  level_1             0.472        0.976
 6 class_1 level_2          -0.00837 level_1             0.970        0.975
 7 class_2 level_1           1.05    level_2             0.402        0.351
 8 class_1 level_1           1.49    level_1             0.850        0.394
 9 class_2 level_1           0.967   level_2             0.757        0.951
10 class_2 level_2           0.603   level_1             0.533        0.107
# ‚Ñπ 90 more rows
# ‚Ñπ 12 more variables: linear_01 &lt;dbl&gt;, linear_02 &lt;dbl&gt;, linear_03 &lt;dbl&gt;,
#   linear_04 &lt;dbl&gt;, linear_05 &lt;dbl&gt;, linear_06 &lt;dbl&gt;, linear_07 &lt;dbl&gt;,
#   linear_08 &lt;dbl&gt;, linear_09 &lt;dbl&gt;, linear_10 &lt;fct&gt;, linear_11 &lt;fct&gt;,
#   linear_12 &lt;fct&gt;</code></pre>
</div>
</div>
<p>‚Ä¶we‚Äôd like to model the <code>class</code> using the remainder of the variables in this dataset using a logistic regression. We can using the following code to do so:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="fu">fit</span>(<span class="fu">logistic_reg</span>(), class <span class="sc">~</span> ., d)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>parsnip model object


Call:  stats::glm(formula = class ~ ., family = stats::binomial, data = data)

Coefficients:
        (Intercept)  two_factor_1level_2         two_factor_2  
           7.080808            -7.463598            -2.821078  
non_linear_1level_2         non_linear_2         non_linear_3  
           0.550041            -0.878752            -2.039599  
          linear_01            linear_02            linear_03  
          -0.153653            -0.273809            -0.005318  
          linear_04            linear_05            linear_06  
           1.248566             0.880917            -0.112520  
          linear_07            linear_08            linear_09  
          -0.925063             1.261782            -1.251249  
   linear_10level_2     linear_10level_3     linear_10level_4  
         -18.020101            -3.242219            -1.336644  
   linear_11level_2     linear_11level_3  
          -0.640718            -4.402850  
 [ reached getOption("max.print") -- omitted 4 entries ]

Degrees of Freedom: 99 Total (i.e. Null);  76 Residual
Null Deviance:      134.6 
Residual Deviance: 54.75    AIC: 102.8</code></pre>
</div>
</div>
<p>The default engine for a logistic regression in tidymodels is <code>stats::glm()</code>. So, in the style of the above graphic, this code:</p>
<ol type="1">
<li>Translates the tidymodels code, which is consistent across engines, to the format that is specific to the chosen engine. In this case, there‚Äôs not a whole lot to do: it passes the preprocessor as <code>formula</code>, the data as <code>data</code>, and picks a <code>family</code> of <code>stats::binomial</code>.</li>
<li>Calls <code>stats::glm()</code> and collects its output.</li>
<li>Translates the output of <code>stats::glm()</code> back into a standardized model fit object.</li>
</ol>
<p>Again, we can control what happens in steps <strong>1)</strong> and <strong>3)</strong>, but step <strong>2)</strong> belongs to the stats package.</p>
<p>The time that steps <strong>1)</strong> and <strong>3)</strong> take is relatively independent of the dimensionality of the training data. That is, regardless of whether we train on one hundred or a million data points, <em>our</em> code (as in, the translation) takes about the same time to run. Regardless of training set size, our code pushes around small, relational data structures to determine how to correctly interface with a given engine. The time it takes to run step <strong>2)</strong>, though, depends almost completely on the size of the data. Depending on the modeling engine, modeling 10 times as much data could result in step <strong>2)</strong> taking twice as long, or 10x as long, or 100x as long as the original fit.</p>
<p>So, while the <em>absolute</em> time allotted to steps <strong>1)</strong> and <strong>3)</strong> is fixed, the <em>portion</em> of total time to fit a model with tidymodels that is ‚Äúoverhead‚Äù depends on how quick the engine code itself is. How quick is a logistic regression with <code>glm()</code> on 100 data points?</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb5"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>bench<span class="sc">::</span><span class="fu">mark</span>(</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>  <span class="at">fit =</span> <span class="fu">glm</span>(class <span class="sc">~</span> ., <span class="at">family =</span> binomial, <span class="at">data =</span> d)</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>) <span class="sc">%&gt;%</span> </span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>  <span class="fu">select</span>(expression, median)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code># A tibble: 1 √ó 2
  expression   median
* &lt;bch:expr&gt; &lt;bch:tm&gt;
1 fit          2.37ms</code></pre>
</div>
</div>
<p>Pretty dang fast. That means that, if the tidymodels overhead is one second, we‚Äôve made this model fit a thousand times slower!</p>
<p>In practice, the overhead here has hovered around a millisecond or two for the last couple years, and machine learning practitioners usually fit much more computationally expensive models than a logistic regression on 100 data points. You‚Äôll just have to believe me on that second point. Regarding the first:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb7"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>bench<span class="sc">::</span><span class="fu">mark</span>(</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>  <span class="at">parsnip =</span> <span class="fu">fit</span>(<span class="fu">logistic_reg</span>(), class <span class="sc">~</span> ., d),</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>  <span class="at">stats =</span> <span class="fu">glm</span>(class <span class="sc">~</span> ., <span class="at">family =</span> binomial, <span class="at">data =</span> d),</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>  <span class="at">check =</span> <span class="cn">FALSE</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell">
<div class="cell-output cell-output-stdout">
<pre><code># A tibble: 2 √ó 3
  expression   median mem_alloc
* &lt;bch:expr&gt; &lt;bch:tm&gt; &lt;bch:byt&gt;
1 parsnip      3.27ms    1.22MB
2 stats        2.35ms    1.21MB</code></pre>
</div>
</div>
<p>Remember that the first expression calls the second one, so the increase in time from the second to the first is the ‚Äúoverhead.‚Äù In this case, it‚Äôs 0.929 milliseconds, or 28.4% of the total elapsed time.</p>
<p>So, to fit a boosted tree model on 1,000,000 data points, step <strong>2)</strong> might take a few seconds. Steps <strong>1)</strong> and <strong>3)</strong> don‚Äôt care about the size of the data, so they still take a few thousandths of a second. No biggie‚Äîthe overhead is negligible. Let‚Äôs quickly back that up by fitting boosted tree models on simulated datasets of varying sizes, once with the XGBoost interface and once with parsnip‚Äôs wrapper around it.</p>
<div class="cell">
<div class="cell-output-display">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="models_files/figure-html/plot-press-boost-tree-1.png" class="img-fluid figure-img" alt="A ggplot line plot displaying numbers of rows, ranging from 100 to a million, on the x axis, and elapsed time, ranging from a millisecond to 10 seconds, on the y axis. One line shows the fit times for XGBoost itself and the other shows XGBoost with parsnip--fit times are only visually different for numbers of rows less than 10,000." width="576"></p>
<figcaption>Elapsed fit times for XGBoost itself versus XBGoost interfaced with through parsnip. Fit times are non-negligigbly different only for very small data.</figcaption>
</figure>
</div>
</div>
</div>
<p>In the left-most model fits on 100 rows, the model fit with XGBoost itself takes 4.7 milliseconds while parsnip takes 8.99, a 91.1% increase in total elapsed time. However, that increase shrinks to 28.7% with an 1000-row dataset, and is fractions of a percent by the time there are hundreds of thousands of rows in the training data. This is the gist of tidymodels‚Äô overhead for modeling engines: as dataset size and model complexity grow larger, the underlying model fit itself takes up increasingly large proportions of the total evaluation time.</p>
<p><a href="intro.html#sec-speedy-go" class="quarto-xref"><span>Section 1.1.3</span></a> showed a number of ways users can cut down on the evaluation time of their tidymodels code. Making use of parallelism, reducing the total number of model fits needed to search a given grid, and carefully constructing that grid to search over are all major parts of the story. However, the rest of this chapter will focus explicitly on choosing performant modeling engines.</p>
</section>
<section id="sec-models-benchmarks" class="level2" data-number="2.2">
<h2 data-number="2.2" class="anchored" data-anchor-id="sec-models-benchmarks"><span class="header-section-number">2.2</span> Benchmarks</h2>
<p>The following is a shiny app based on experimental benchmarks. For a given selection of model configurations, the app displays the time to resample various model configurations across a given number of rows of training data.</p>
<!--# Going to take some work for this not to feel super rote.  -->
<!--# I do want some kind of content that's, like, tables of timings for every ___ engine fitted on a bunch of numbers of rows.  -->
<pre class="shinylive-r" data-engine="r"><code>#| '!! shinylive warning !!': |
#|   shinylive does not work in self-contained HTML documents.
#|   Please set `embed-resources: false` in your metadata.
#| label: models-app
#| embed-resources: false
#| standalone: true
#| viewerHeight: 600
#| eval: true
#| echo: false
library(ggplot2)
library(bench)
library(qs)
library(shiny)
library(bslib)
library(shinylive)
library(scales)

options(
  ggplot2.discrete.colour = c(
    "#1a162d", "#42725c", "#cd6f3d", "#a8ab71",
    "#8b4b65", "#557088", "#d9b594", "#6b705c", "#956b4b", "#2d4041"
  )
)

n_rows &lt;- round(10^seq(from = 2, to = 6, by = .5))
reference_mark &lt;- 37002
footer_context &lt;- paste0(collapse = "", c(
  "Timings estimate the time to evaluate an initial set of 10 models across 10 ",
  "resamples, resulting in 100 model fits on 9/10th of rows, 100 sets of ",
  "predictions on 1/10th of rows, and metric calculations on each set of predictions."
))

load(url("https://raw.githubusercontent.com/simonpcouch/emlwr/main/data/models/app/bm.rda"))
load(url("https://raw.githubusercontent.com/simonpcouch/emlwr/main/data/models/app/cpus.rda"))

# copying over r-lib/bench#144
bench_time_trans &lt;- function(base = 10) {
  if (is.null(base)) {
    return(
      scales::trans_new("bch:tm", as.numeric, as_bench_time,
                        breaks = scales::pretty_breaks(), domain = c(1e-100, Inf)
      )
    )
  }
  trans &lt;- function(x) log(as.numeric(x), base)
  inv &lt;- function(x) bench::as_bench_time(base ^ as.numeric(x))
  
  trans_new(paste0("bch:tm-", format(base)), trans, inv, 
            breaks = log_breaks(base = base), domain = c(1e-100, Inf))
}

ui &lt;- page_fillable(
  theme = bs_theme(
    bg = "#ffffff",
    fg = "#333333",
    primary = "#42725c",
    font_scale = .8
  ),
  title = "Time To Tune",
  layout_columns(
    selectInput(
      "model", "Model:",
      choices = unique(bm$model),
      multiple = TRUE,
      selected = c(
        "linear_reg (glmnet)", 
        "boost_tree (xgboost)",
        "boost_tree (lightgbm)"
      )
    )
  ),
  layout_sidebar(
    sidebar = sidebar(
      open = "always",
      position = "right",
      selectInput(
        "task", "Task:",
        choices = unique(bm$task),
        selected = "regression"
      ),
      sliderInput(
        "n_workers", "Number of Workers:",
        value = 1,
        min = 1,
        max = 10,
        step = 1
      ),
      selectInput(
        "tuning_fn", "Tuning Function:",
        choices = unique(bm$tuning_fn)
      ),
      selectInput(
        "cpu", "CPU:", 
        choices = NULL
      ),
      markdown("Timings scaled according to [CPU benchmarks](https://www.cpubenchmark.net/cpu_list.php).")
    ),
    card(
      full_screen = TRUE,
      card_header("Time To Tune"),
      plotOutput("plot"),
      footer = footer_context
    )
  )
)

server &lt;- function(input, output, session) {
  updateSelectizeInput(
    session,
    'cpu',
    choices = cpus$name,
    server = TRUE,
    selected = "Intel Core i7-13700"
  )
  
  output$plot &lt;- renderPlot({
    new_data &lt;- bm[
      bm$model %in% input$model &amp;
        bm$task == input$task &amp;
        bm$n_workers == input$n_workers &amp;
        bm$tuning_fn == input$tuning_fn,
    ]
    
    if (!identical(input$cpu, "")) {
      new_data$time_to_tune_float &lt;-
        new_data$time_to_tune_float *
        (reference_mark / cpus$mark[cpus$name == input$cpu])
      new_data$time_to_tune &lt;- as_bench_time(new_data$time_to_tune_float)
    }
    
    ggplot(new_data, aes(x = n_rows, y = time_to_tune, col = model, group = model)) +
      geom_point() +
      geom_line() +
      scale_x_log10(labels = comma) +
      scale_y_continuous(trans = bench_time_trans(base = 10)) +
      labs(x = "Number of Rows", y = "Time to Tune (seconds)", col = "Model") +
      theme(
        legend.position = "bottom"
      )
  })
}

app &lt;- shinyApp(ui, server)

app</code></pre>
<p>This app allows for quickly juxtaposing the time that it might take to evaluate performance across various modeling approaches. In <a href="#sec-models-one-data-point" class="quarto-xref"><span>Section 2.2.1</span></a>, I‚Äôll go into a bit more detail about what each data point in this app represents and why, and then analyze the data in further detail in <a href="#sec-models-analysis" class="quarto-xref"><span>Section 2.2.3</span></a>.</p>
<section id="sec-models-one-data-point" class="level3" data-number="2.2.1">
<h3 data-number="2.2.1" class="anchored" data-anchor-id="sec-models-one-data-point"><span class="header-section-number">2.2.1</span> One data point</h3>
<p>When the app first starts, the left-most point labeled <code>boost_tree (lightgbm)</code> is the observed time to sequentially evaluate an initial set of 10 models across 10 cross-validation folds of an 1000 row training set, resulting in 100 model fits on 900 rows, 100 sets of predictions of 100 rows, and metric calculations on each set of predictions. The actual benchmarking code is a bit more involved, but the code underlying that single data point looks something like the following.</p>
<p>First, we load core packages as well as the bonsai parsnip extension (for lightgbm support):</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb10"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(tidymodels)</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(bonsai)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Next, we‚Äôll simulate a dataset with 1000 rows using <code>simulate_regression()</code>, <em>Efficient Machine Learning with R</em>‚Äôs in-house simulation function:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb11"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a>d <span class="ot">&lt;-</span> <span class="fu">simulate_regression</span>(<span class="dv">1000</span>)</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>d</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code># A tibble: 1,000 √ó 16
   outcome predictor_01 predictor_02 predictor_03 predictor_04 predictor_05
     &lt;dbl&gt;        &lt;dbl&gt;        &lt;dbl&gt;        &lt;dbl&gt;        &lt;dbl&gt;        &lt;dbl&gt;
 1  -13.8         2.28        -0.419      -0.0188       -0.104      -1.10  
 2   26.6        -6.86        -1.37        0.434         4.77       -1.19  
 3   14.9         1.55         2.95        1.60         -0.888       0.0702
 4   24.1        -4.04         2.06       -3.53          3.97       -1.17  
 5   11.0         1.09        -3.33        7.45         -3.61        1.45  
 6   39.0         3.94         1.62       -4.00         -2.54        2.28  
 7    8.82       -1.34         2.34       -4.08          0.980       0.512 
 8   15.5        -2.42        -3.58       -0.705        -4.38        5.27  
 9   27.5        -0.259       -0.742      -0.269         3.67       -3.87  
10   16.2         4.76         4.96        0.602        -0.513       4.05  
# ‚Ñπ 990 more rows
# ‚Ñπ 10 more variables: predictor_06 &lt;dbl&gt;, predictor_07 &lt;dbl&gt;,
#   predictor_08 &lt;dbl&gt;, predictor_09 &lt;dbl&gt;, predictor_10 &lt;fct&gt;,
#   predictor_11 &lt;fct&gt;, predictor_12 &lt;fct&gt;, predictor_13 &lt;fct&gt;,
#   predictor_14 &lt;fct&gt;, predictor_15 &lt;fct&gt;</code></pre>
</div>
</div>
<p>This step would happen as-is for every regression task on 1000 rows.</p>
<p>Now, splitting the data into 10 folds using cross-validation:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb13"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a>d_folds <span class="ot">&lt;-</span> <span class="fu">vfold_cv</span>(d, <span class="at">v =</span> <span class="dv">10</span>)</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>d_folds</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>#  10-fold cross-validation 
# A tibble: 10 √ó 2
   splits            id    
   &lt;list&gt;            &lt;chr&gt; 
 1 &lt;split [900/100]&gt; Fold01
 2 &lt;split [900/100]&gt; Fold02
 3 &lt;split [900/100]&gt; Fold03
 4 &lt;split [900/100]&gt; Fold04
 5 &lt;split [900/100]&gt; Fold05
 6 &lt;split [900/100]&gt; Fold06
 7 &lt;split [900/100]&gt; Fold07
 8 &lt;split [900/100]&gt; Fold08
 9 &lt;split [900/100]&gt; Fold09
10 &lt;split [900/100]&gt; Fold10</code></pre>
</div>
</div>
<p>Now, we specify a boosted tree model specification using the LightGBM engine. In this experiment, any tunable parameter (defined by whether tidymodels has a parameter definition that automatically kicks in when generating grids) is set to be tuned.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb15"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a>spec <span class="ot">&lt;-</span> </span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">boost_tree</span>(</span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>    <span class="at">tree_depth =</span> <span class="fu">tune</span>(),</span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a>    <span class="at">trees =</span> <span class="fu">tune</span>(),</span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a>    <span class="at">learn_rate =</span> <span class="fu">tune</span>(),</span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a>    <span class="at">mtry =</span> <span class="fu">tune</span>(),</span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a>    <span class="at">min_n =</span> <span class="fu">tune</span>(),</span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true" tabindex="-1"></a>    <span class="at">loss_reduction =</span> <span class="fu">tune</span>(),</span>
<span id="cb15-9"><a href="#cb15-9" aria-hidden="true" tabindex="-1"></a>    <span class="at">sample_size =</span> <span class="fu">tune</span>(),</span>
<span id="cb15-10"><a href="#cb15-10" aria-hidden="true" tabindex="-1"></a>    <span class="at">stop_iter =</span> <span class="fu">tune</span>()</span>
<span id="cb15-11"><a href="#cb15-11" aria-hidden="true" tabindex="-1"></a>  ) <span class="sc">%&gt;%</span></span>
<span id="cb15-12"><a href="#cb15-12" aria-hidden="true" tabindex="-1"></a>  <span class="fu">set_engine</span>(<span class="st">"lightgbm"</span>) <span class="sc">%&gt;%</span></span>
<span id="cb15-13"><a href="#cb15-13" aria-hidden="true" tabindex="-1"></a>  <span class="fu">set_mode</span>(<span class="st">"regression"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Each of these model fits are carried out with minimal preprocessors based on <em>Tidy Modeling with R‚Äôs</em> ‚ÄúRecommended Preprocessing‚Äù appendix <span class="citation" data-cites="kuhn2022">(<a href="references.html#ref-kuhn2022" role="doc-biblioref">Max Kuhn and Silge 2022</a>)</span>. In this case, Kuhn and Silge recommend that users impute missing values for both numeric predictors (we do so using the median for all) and categorical predictors (we do so using the mode) when working with boosted trees.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb16"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a>rec <span class="ot">&lt;-</span> </span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">recipe</span>(outcome <span class="sc">~</span> ., d) <span class="sc">%&gt;%</span></span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>  <span class="fu">step_impute_median</span>(<span class="fu">all_numeric_predictors</span>()) <span class="sc">%&gt;%</span></span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a>  <span class="fu">step_impute_mode</span>(<span class="fu">all_nominal_predictors</span>())</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>With our data resampled and a modeling workflow defined, we‚Äôre ready to resample this model. The resampling process will propose 10 different possible sets of parameter values for each parameter tagged with <code>tune()</code>. This will happen automatically under the hood of <code>tune_grid()</code>, but we can replicate this ourselves using dials:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb17"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="fu">extract_parameter_set_dials</span>(spec) <span class="sc">%&gt;%</span> </span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">finalize</span>(d) <span class="sc">%&gt;%</span></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>  <span class="fu">grid_space_filling</span>(<span class="at">size =</span> <span class="dv">10</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code># A tibble: 10 √ó 8
    mtry trees min_n tree_depth  learn_rate loss_reduction sample_size stop_iter
   &lt;int&gt; &lt;int&gt; &lt;int&gt;      &lt;int&gt;       &lt;dbl&gt;          &lt;dbl&gt;       &lt;dbl&gt;     &lt;int&gt;
 1     1   445    23         10       1e-10       4.64e- 3         0.7        18
 2     2  1555     2         15       1e- 3       2.45e- 4         0.5        12
 3     4   889    31          4       1e- 7       3.16e+ 1         0.3         3
 4     6   223    35          5       1e- 1       3.59e- 8         0.6        16
 5     7  1111    10          2       1e- 9       1   e-10         0.9         8
 6     9  2000    40         11       1e- 5       1.90e- 9         0.4         6
 7    11  1777    14          1       1e- 2       1.67e+ 0         0.8        14
 8    12     1     6          8       1e- 4       6.81e- 7         0.2         4
 9    14  1333    18          7       1e- 8       1.29e- 5         0.1        20
10    16   667    27         13       1e- 6       8.80e- 2         1          10</code></pre>
</div>
</div>
<p><code>tune_grid()</code> will evaluate those sets of values by fitting them to 10 different subsets of <code>d</code>.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb19"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">1</span>)</span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>res <span class="ot">&lt;-</span> <span class="fu">tune_grid</span>(<span class="fu">workflow</span>(rec, spec), d_folds)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>The point in the above plot is the time that those 100 model fits took altogether; in other words, the time that we‚Äôd wait for <code>tune_grid()</code> to evaluate.</p>
<p>The data underlying this app is generated from thousands of experiments that look just like the one above, but varying the structure of the training data, the numbers of rows in the training data and the number of CPU cores utilized. In all, 585 such experiments form the underlying data for this app:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb20"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a>bm</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell">
<div class="cell-output cell-output-stdout">
<pre><code># A tibble: 10 √ó 8
   model                          task           n_rows n_workers tuning_fn
   &lt;fct&gt;                          &lt;fct&gt;           &lt;dbl&gt;     &lt;dbl&gt; &lt;fct&gt;    
 1 decision_tree (partykit)       regression       2512         1 tune_grid
 2 rule_fit (xrf)                 regression       1000         1 tune_grid
 3 rand_forest (ranger)           classification   6310         2 tune_grid
 4 mars (earth)                   regression       1000         1 tune_grid
 5 logistic_reg (LiblineaR)       classification  15849         2 tune_grid
 6 discrim_linear (sparsediscrim) classification   6310         1 tune_grid
 7 mars (earth)                   regression       6310         1 tune_grid
 8 logistic_reg (LiblineaR)       classification   6310         1 tune_grid
 9 rand_forest (ranger)           regression      39811         2 tune_grid
10 multinom_reg (glmnet)          classification  15849         2 tune_grid
# ‚Ñπ 3 more variables: time_to_tune &lt;bch:tm&gt;, time_to_tune_float &lt;dbl&gt;,
#   strategy &lt;fct&gt;</code></pre>
</div>
</div>
</section>
<section id="why-not-just-model-fits" class="level3" data-number="2.2.2">
<h3 data-number="2.2.2" class="anchored" data-anchor-id="why-not-just-model-fits"><span class="header-section-number">2.2.2</span> Why not just model fits?</h3>
<p>This seems a bit involved for the purposes of getting a rough sense of how long a given model may take to fit; why don‚Äôt we just use default parameter values from tidymodels and pass the model specification straight to <code>fit()</code>?</p>
<p>There are a few reasons for this. In general, though, resampling a model specification across an initial set of possible parameter values is a fundamental unit of interactive machine learning. This initial resampling process gives the practitioner a sense for the ballpark of predictive performance she can expect for a given model task and how various parameter values may affect that performance. Does a higher <code>learn_rate</code> result in better predictive performance? How many <code>trees</code> is enough? A single model fit leaves the answer to all of these questions unknown.</p>
<p>Importantly, too, the time that a given model specification takes to fit can vary greatly depending on parameter values. For example, only exploring the time to <code>fit()</code> rather than resample across a set of values would obscure the difference in these two elapsed times:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb22"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a>spec <span class="ot">&lt;-</span> <span class="fu">boost_tree</span>(<span class="at">mode =</span> <span class="st">"regression"</span>, <span class="at">engine =</span> <span class="st">"lightgbm"</span>)</span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a>bench<span class="sc">::</span><span class="fu">mark</span>(</span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a>  <span class="at">few_trees =</span> <span class="fu">fit</span>(spec <span class="sc">%&gt;%</span> <span class="fu">set_args</span>(<span class="at">trees =</span> <span class="dv">10</span>), outcome <span class="sc">~</span> ., d),</span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true" tabindex="-1"></a>  <span class="at">many_trees =</span> <span class="fu">fit</span>(spec <span class="sc">%&gt;%</span> <span class="fu">set_args</span>(<span class="at">trees =</span> <span class="dv">1000</span>), outcome <span class="sc">~</span> ., d),</span>
<span id="cb22-6"><a href="#cb22-6" aria-hidden="true" tabindex="-1"></a>  <span class="at">check =</span> <span class="cn">FALSE</span></span>
<span id="cb22-7"><a href="#cb22-7" aria-hidden="true" tabindex="-1"></a>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell">
<div class="cell-output cell-output-stdout">
<pre><code># A tibble: 2 √ó 3
  expression   median mem_alloc
* &lt;bch:expr&gt; &lt;bch:tm&gt; &lt;bch:byt&gt;
1 few_trees    13.7ms    5.06MB
2 many_trees  458.8ms    1.41MB</code></pre>
</div>
</div>
<p>By summing across many model configurations that result in varied fit times, we can get a better sense for a typical time to fit across typical parameter values.</p>
</section>
<section id="sec-models-analysis" class="level3" data-number="2.2.3">
<h3 data-number="2.2.3" class="anchored" data-anchor-id="sec-models-analysis"><span class="header-section-number">2.2.3</span> Analysis</h3>
<!--# TODO: is an app that explores variations in fit times within a resampling process worth looking into? -->
<!--# TODO: next bit is just a guided analysis of the data. this will live in both the web and print version of the book, but the book will need its own initial view of the data. -->
<section id="decision-trees" class="level4" data-number="2.2.3.1">
<h4 data-number="2.2.3.1" class="anchored" data-anchor-id="decision-trees"><span class="header-section-number">2.2.3.1</span> Decision Trees</h4>
<p>Decision trees recursively partition data by selecting values of predictor variables that, when split at that value, best predict the outcome at each node. The tree makes predictions by routing new samples through these splits to reach leaf nodes containing similar training examples. The tidymodels framework supports a number of modeling engines for fitting and predicting from decision trees, including C5.0, partykit, rpart, and spark, and decision trees can be used for either classification or regression (with some engine-specific exceptions).</p>
<p>At the highest level, here‚Äôs what the tuning times for various <code>decision_tree()</code> engines supported by tidymodels look like:</p>
<div class="cell">
<div class="cell-output-display">
<div id="fig-decision-tree-engines" class="quarto-float quarto-figure quarto-figure-center anchored" alt="A line plot comparing performance of C5.0, partykit, and rpart engines across different dataset sizes. The x-axis shows number of rows (from 1,000 to 100,000) on a log scale, while y-axis shows time to tune on a log scale. C5.0 shows the highest elapsed times, followed by rpart, while partykit consistently evaluates most quickly.">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-decision-tree-engines-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="models_files/figure-html/fig-decision-tree-engines-1.png" class="img-fluid figure-img" alt="A line plot comparing performance of C5.0, partykit, and rpart engines across different dataset sizes. The x-axis shows number of rows (from 1,000 to 100,000) on a log scale, while y-axis shows time to tune on a log scale. C5.0 shows the highest elapsed times, followed by rpart, while partykit consistently evaluates most quickly." width="576">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-decision-tree-engines-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;2.1: Elapsed times to generate preliminary tuning results for decision trees with tidymodels by modeling engine.
</figcaption>
</figure>
</div>
</div>
</div>
<p><a href="#fig-decision-tree-engines" class="quarto-xref">Figure&nbsp;<span>2.1</span></a> is a special case of the Time to Tune app from <a href="#sec-models-benchmarks" class="quarto-xref"><span>Section 2.2</span></a>; each data point shows the total time to fit and predict from 100 decision trees of varying parameterizations. <code>partykit</code> consistently evaluates the fastest across all dataset sizes, while <code>C5.0</code> is the slowest, with the performance gap between engines widening as the number of rows increases.</p>
<p>tidymodels supports tuning the decision tree hyperparameters <code>min_n</code>, <code>tree_depth</code>, and <code>cost_complexity</code>.<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a> We‚Äôll discuss the implications for each on the time to fit decision trees in the rest of this section. In general, though, it‚Äôs helpful to keep in mind that the computationally intensive part of fitting decision trees is the search for optimal split points. Because of this, more complex trees generally take longer to fit than less complex trees, and parameter values allowing for more complex trees will tend to result in longer fit times. That said, the effect on fit time of changing individual parameter values is often relatively mild, as changes in one parameter value are mediated by other parameters.</p>
<p>First, the <strong>Minimum Points Per Node</strong>, or <code>min_n</code>, is the minimum number of training set observations in a node required for the node to be split further. For example, if only 3 observations meet some split criteria <code>some_variable &lt; 2</code> and <code>min_n</code> is set to 3, then the tree will make a prediction at that node rather than considering whether to further break those 3 observations up into smaller buckets based on another split criteria before making predictions. Smaller values of <code>min_n</code> allow for more complex trees, and thus the time to fit a decision tree is inversely correlated to <code>min_n</code> when the complexity of the tree isn‚Äôt mediated by other parameter values. In CART-based settings like with <code>engine = "rpart"</code>, <code>min_n</code> can usually be set to a reasonably high value without affecting predictive performance ‚Äúsince smaller nodes are almost always pruned away by cross-validation‚Äù; in other words, even if the tree is allowed to generate more splits via a small <code>min_n</code> value, those splits based on smaller numbers of observations are often pruned away via the <code>cost_complexity</code> parameter anyway <span class="citation" data-cites="pkgrpart">(<a href="references.html#ref-pkgrpart" role="doc-biblioref">Therneau and Atkinson 2025</a>)</span>.</p>
<p>Let‚Äôs see how this plays out in practice:</p>
<div class="cell">
<div class="cell-output-display">
<div id="fig-decision-tree-timings-by-min-n" class="quarto-float quarto-figure quarto-figure-center anchored" alt="A ggplot2 dotplot faceted by engine showing elapsed computation time versus minimum points per node. The x-axis shows parameter values from 0 to 40, while the y-axis shows elapsed time on a log scale from 1ms to 10s. Each engine panel contains scattered points colored by dataset size (1,000 to 100,000 rows), showing that fit times don't tend to vary relative to minimum points per node.">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-decision-tree-timings-by-min-n-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="models_files/figure-html/fig-decision-tree-timings-by-min-n-1.png" class="img-fluid figure-img" style="width:100.0%" alt="A ggplot2 dotplot faceted by engine showing elapsed computation time versus minimum points per node. The x-axis shows parameter values from 0 to 40, while the y-axis shows elapsed time on a log scale from 1ms to 10s. Each engine panel contains scattered points colored by dataset size (1,000 to 100,000 rows), showing that fit times don't tend to vary relative to minimum points per node.">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-decision-tree-timings-by-min-n-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;2.2: Distributions of time-to-fit for various minimum points per node values, faceted by engine and colored according to numbers of rows. Generally, in practice, the minimum points per node doesn‚Äôt tend to affect fit times as tree complexity is mediated by other parameter values.
</figcaption>
</figure>
</div>
</div>
</div>
<p>This plot disaggregates the information in <a href="#fig-decision-tree-engines" class="quarto-xref">Figure&nbsp;<span>2.1</span></a>. Instead of summing across the time to fit and predict from each model to determine a data point (with varying values of <code>min_n</code> and other parameters), this plot shows one point per model fit. Generally, we see that <code>min_n</code> has little effect on the time to fit across all modeling engines supported by tidymodels.</p>
<p>The <strong>Tree Depth</strong>, or <code>tree_depth</code> in tidymodels, is the maximum depth of the tree. For example, if <code>tree_depth = 2</code>, the tree must reach a node (i.e.&nbsp;a point at which a prediction is made rather than a further split) after splitting twice. Larger values of <code>tree_depth</code> allow for more complex trees, and thus the time to fit a decision tree increases as <code>tree_depth</code> does unless the complexity of the tree is mediated by some other parameter.</p>
<div class="cell">
<div class="cell-output-display">
<div id="fig-decision-tree-timings-by-tree-depth" class="quarto-float quarto-figure quarto-figure-center anchored" alt="An identical plot to that above but plotting tree depth instead of minimum points per node. The C5.0 panel is empty, while partykit and rpart panels show positive correlation between tree depth and computation time, with larger datasets taking longer to compute across all depths.">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-decision-tree-timings-by-tree-depth-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="models_files/figure-html/fig-decision-tree-timings-by-tree-depth-1.png" class="img-fluid figure-img" style="width:100.0%" alt="An identical plot to that above but plotting tree depth instead of minimum points per node. The C5.0 panel is empty, while partykit and rpart panels show positive correlation between tree depth and computation time, with larger datasets taking longer to compute across all depths.">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-decision-tree-timings-by-tree-depth-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;2.3: Distributions of time-to-fit for various tree depth values, faceted by engine and colored according to numbers of rows. For the engines that support tree depth, higher values of tree depth tend to result in greater fit times, even as other parameter values vary. C5.O doesn‚Äôt support the tree depth parameter <span class="citation" data-cites="pkgC50 pkgC502">(<a href="references.html#ref-pkgC50" role="doc-biblioref">Max Kuhn and Quinlan 2023</a>; <a href="references.html#ref-pkgC502" role="doc-biblioref">Quinlan 2014</a>)</span>.
</figcaption>
</figure>
</div>
</div>
</div>
<p>The <strong>Cost of Complexity</strong>, or <code>cost_complexity</code> in tidymodels, is a penalization parameter (often referred to as <span class="math inline">\(C_p\)</span>) on adding additional complexity to the tree. This parameter is only used by CART models, so is available only for specific engines. When training CART-based decision trees, once splits are generated, each are evaluated according to how much they decrease error on out-of-sample data relative to the tree without that split. If the decrease in error doesn‚Äôt surpass some threshold <span class="math inline">\(C_p\)</span>, the split is ‚Äúpruned‚Äù back, forming a less complex tree. Higher values of penalization mean that the decision tree will evaluate (and thus search for) fewer splits in total, ultimately saving ‚Äúconsiderable computational effort‚Äù and decreasing the time to fit the model <span class="citation" data-cites="pkgrpart kuhn2013applied">(<a href="references.html#ref-pkgrpart" role="doc-biblioref">Therneau and Atkinson 2025</a>; <a href="references.html#ref-kuhn2013applied" role="doc-biblioref">M. Kuhn 2013</a>)</span>.</p>
<div class="cell">
<div class="cell-output-display">
<div id="fig-decision-tree-timings-by-cost-complexity" class="quarto-float quarto-figure quarto-figure-center anchored" alt="An identical plot to that above but plotting cost of complexity instead of tree depth. The C5.0 and partykit panels are empty, while rpart panel shows scattered points across complexity values, with computation time primarily determined by dataset size rather than complexity parameter.">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-decision-tree-timings-by-cost-complexity-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="models_files/figure-html/fig-decision-tree-timings-by-cost-complexity-1.png" class="img-fluid figure-img" style="width:100.0%" alt="An identical plot to that above but plotting cost of complexity instead of tree depth. The C5.0 and partykit panels are empty, while rpart panel shows scattered points across complexity values, with computation time primarily determined by dataset size rather than complexity parameter.">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-decision-tree-timings-by-cost-complexity-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;2.4: Distributions of time-to-fit for various values of cost of complexity, faceted by engine and colored according to numbers of rows. Neither C5.0 nor partykit make use of this parameter <span class="citation" data-cites="pkgC502 pkgpartykit2">(<a href="references.html#ref-pkgC502" role="doc-biblioref">Quinlan 2014</a>; <a href="references.html#ref-pkgpartykit2" role="doc-biblioref">Hothorn, Hornik, and Zeileis 2006</a>)</span>.
</figcaption>
</figure>
</div>
</div>
</div>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Note
</div>
</div>
<div class="callout-body-container callout-body">
<p>C5.0 and partykit make use of related parameters to automatically prune trees, though they aren‚Äôt supported by tidymodels as a default tuning parameter as they‚Äôre engine-specific. C5.0‚Äôs <em>confidence factor</em> parameter is a very computationally efficient way to control complexity, though do note that the approach stands on ‚Äúshaky statistical grounds‚Äù <span class="citation" data-cites="kuhn2013applied">(<a href="references.html#ref-kuhn2013applied" role="doc-biblioref">M. Kuhn 2013</a>)</span>. partykit determines whether a split is ‚Äúworth it‚Äù based on hypothesis testing, and the significance level of that hypothesis test can be used to prune splits more aggressively <span class="citation" data-cites="pkgpartykit2">(<a href="references.html#ref-pkgpartykit2" role="doc-biblioref">Hothorn, Hornik, and Zeileis 2006</a>)</span>.</p>
</div>
</div>
<p>Again, the time-consuming portion of fitting decision trees is searching for optimal predictor values to split on. Because of this, more complex trees tend to take longer to fit than less complex trees. On its own, though, this doesn‚Äôt necessarily mean that setting an individual parameter value to allow for a more complex tree will result in a longer fit time, and we saw this effect above. Instead, the complex interplay of many parameter values simultaneously allowing for greater complexity is what drives longer fit times. We can quickly demonstrate this in-the-small with a brief set of model fits.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb24"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="co"># generate a dataset with 100,000 rows</span></span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">1</span>)</span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a>d <span class="ot">&lt;-</span> <span class="fu">simulate_classification</span>(<span class="dv">100000</span>)</span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-5"><a href="#cb24-5" aria-hidden="true" tabindex="-1"></a><span class="co"># define a decision tree model specification</span></span>
<span id="cb24-6"><a href="#cb24-6" aria-hidden="true" tabindex="-1"></a>spec_small <span class="ot">&lt;-</span>  </span>
<span id="cb24-7"><a href="#cb24-7" aria-hidden="true" tabindex="-1"></a>  <span class="fu">decision_tree</span>(<span class="at">cost_complexity =</span> .<span class="dv">1</span>, <span class="at">tree_depth =</span> <span class="dv">2</span>, <span class="at">min_n =</span> <span class="dv">1000</span>) <span class="sc">%&gt;%</span></span>
<span id="cb24-8"><a href="#cb24-8" aria-hidden="true" tabindex="-1"></a>  <span class="fu">set_engine</span>(<span class="st">"rpart"</span>) <span class="sc">%&gt;%</span></span>
<span id="cb24-9"><a href="#cb24-9" aria-hidden="true" tabindex="-1"></a>  <span class="fu">set_mode</span>(<span class="st">"classification"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>In the above, <code>spec_small</code> defines a very minimal tree; this <code>cost_complexity()</code> value heavily penalizes further splits, the <code>tree_depth</code> describes a very shallow tree, and <code>min_n</code> only allows for further splits when a given split contains <em>many</em> observations.</p>
<p>Now, we can examine the effect of setting individual values on fit time by benchmarking the time to fit a simple tree by all measures, then toggling each of the parameter values individually to allow for more complex trees, and finally by toggling all of them to allow for a very complex tree.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb25"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a>bench<span class="sc">::</span><span class="fu">mark</span>(</span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a>  <span class="co"># small by all measures</span></span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a>  <span class="at">small =</span> <span class="fu">fit</span>(<span class="at">object =</span> spec_small, <span class="at">formula =</span> class <span class="sc">~</span> ., <span class="at">data =</span> d),</span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb25-5"><a href="#cb25-5" aria-hidden="true" tabindex="-1"></a>  <span class="co"># allowing for greater complexity with only one parameter value</span></span>
<span id="cb25-6"><a href="#cb25-6" aria-hidden="true" tabindex="-1"></a>  <span class="at">complex_cost_complexity =</span> <span class="fu">fit</span>(</span>
<span id="cb25-7"><a href="#cb25-7" aria-hidden="true" tabindex="-1"></a>    <span class="fu">set_args</span>(spec_small, <span class="at">cost_complexity =</span> <span class="fl">10e-9</span>), class <span class="sc">~</span> ., d</span>
<span id="cb25-8"><a href="#cb25-8" aria-hidden="true" tabindex="-1"></a>  ),</span>
<span id="cb25-9"><a href="#cb25-9" aria-hidden="true" tabindex="-1"></a>  <span class="at">complex_tree_depth =</span> <span class="fu">fit</span>(</span>
<span id="cb25-10"><a href="#cb25-10" aria-hidden="true" tabindex="-1"></a>    <span class="fu">set_args</span>(spec_small, <span class="at">tree_depth =</span> <span class="dv">30</span>), class <span class="sc">~</span> ., d</span>
<span id="cb25-11"><a href="#cb25-11" aria-hidden="true" tabindex="-1"></a>  ),</span>
<span id="cb25-12"><a href="#cb25-12" aria-hidden="true" tabindex="-1"></a>  <span class="at">complex_min_n =</span> <span class="fu">fit</span>(</span>
<span id="cb25-13"><a href="#cb25-13" aria-hidden="true" tabindex="-1"></a>    <span class="fu">set_args</span>(spec_small, <span class="at">min_n =</span> <span class="dv">1</span>), class <span class="sc">~</span> ., d</span>
<span id="cb25-14"><a href="#cb25-14" aria-hidden="true" tabindex="-1"></a>  ),</span>
<span id="cb25-15"><a href="#cb25-15" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb25-16"><a href="#cb25-16" aria-hidden="true" tabindex="-1"></a>  <span class="co"># allowing for greater complexity with all parameter values</span></span>
<span id="cb25-17"><a href="#cb25-17" aria-hidden="true" tabindex="-1"></a>  <span class="at">complex =</span> <span class="fu">fit</span>(</span>
<span id="cb25-18"><a href="#cb25-18" aria-hidden="true" tabindex="-1"></a>    <span class="fu">set_args</span>(spec_small, <span class="at">cost_complexity =</span> <span class="fl">10e-9</span>, <span class="at">tree_depth =</span> <span class="dv">30</span>, <span class="at">min_n =</span> <span class="dv">1</span>),</span>
<span id="cb25-19"><a href="#cb25-19" aria-hidden="true" tabindex="-1"></a>    class <span class="sc">~</span> ., </span>
<span id="cb25-20"><a href="#cb25-20" aria-hidden="true" tabindex="-1"></a>    d</span>
<span id="cb25-21"><a href="#cb25-21" aria-hidden="true" tabindex="-1"></a>  ),</span>
<span id="cb25-22"><a href="#cb25-22" aria-hidden="true" tabindex="-1"></a>  <span class="at">check =</span> <span class="cn">FALSE</span></span>
<span id="cb25-23"><a href="#cb25-23" aria-hidden="true" tabindex="-1"></a>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell">
<div class="cell-output cell-output-stdout">
<pre><code># A tibble: 5 √ó 3
  expression                median mem_alloc
* &lt;bch:expr&gt;              &lt;bch:tm&gt; &lt;bch:byt&gt;
1 small                   750.08ms     102MB
2 complex_cost_complexity 814.43ms     102MB
3 complex_tree_depth          1.2s     102MB
4 complex_min_n           749.36ms     102MB
5 complex                    7.16s     124MB</code></pre>
</div>
</div>
<p>Again, we see that individual parameter values allowing for greater complexity are mediated by other parameter values, but setting them all together allows for a complex tree and, thus, a significantly longer fit time.</p>
<p><em>Summary: Decision Trees</em></p>
<ul>
<li>More complex decision trees take longer to fit.</li>
<li>Setting individual parameter values to allow for more complex fits doesn‚Äôt necessarily mean that a tree will take longer to fit.</li>
<li>Compared to many of the other methods described in this chapter, decision trees are quite quick-fitting.</li>
</ul>


<div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0" role="list" style="display: none">
<div id="ref-pkgpartykit2" class="csl-entry" role="listitem">
Hothorn, Torsten, Kurt Hornik, and Achim Zeileis. 2006. <span>‚ÄúUnbiased Recursive Partitioning: A Conditional Inference Framework.‚Äù</span> <em>Journal of Computational and Graphical Statistics</em> 15 (3): 651‚Äì74. <a href="https://doi.org/10.1198/106186006X133933">https://doi.org/10.1198/106186006X133933</a>.
</div>
<div id="ref-kuhn2013applied" class="csl-entry" role="listitem">
Kuhn, M. 2013. <span>‚ÄúApplied Predictive Modeling.‚Äù</span> Springer.
</div>
<div id="ref-pkgC50" class="csl-entry" role="listitem">
Kuhn, Max, and Ross Quinlan. 2023. <em><span>C50</span>: C5.0 Decision Trees and Rule-Based Models</em>. <a href="https://CRAN.R-project.org/package=C50">https://CRAN.R-project.org/package=C50</a>.
</div>
<div id="ref-kuhn2022" class="csl-entry" role="listitem">
Kuhn, Max, and Julia Silge. 2022. <em>Tidy Modeling with <span>R</span></em>. " O‚ÄôReilly Media, Inc.".
</div>
<div id="ref-pkgC502" class="csl-entry" role="listitem">
Quinlan, J Ross. 2014. <em><span>C4.5</span>: Programs for Machine Learning</em>. Elsevier.
</div>
<div id="ref-pkgrpart" class="csl-entry" role="listitem">
Therneau, Terry, and Beth Atkinson. 2025. <em>Rpart: Recursive Partitioning and Regression Trees</em>. <a href="https://CRAN.R-project.org/package=rpart">https://CRAN.R-project.org/package=rpart</a>.
</div>
</div>
</section>
</section>
</section>
<section id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes">
<hr>
<ol>
<li id="fn1"><p>That is, tidymodels provides default distributions of parameter values to sample from for these parameters. Other parameters can be tuned by providing your own distributions using the dials package.<a href="#fnref1" class="footnote-back" role="doc-backlink">‚Ü©Ô∏é</a></p></li>
</ol>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "Óßã";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
      <a href="./intro.html" class="pagination-link" aria-label="Introduction">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">Introduction</span></span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
      <a href="./parallelism.html" class="pagination-link" aria-label="Parallel computing">
        <span class="nav-page-text"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Parallel computing</span></span> <i class="bi bi-arrow-right-short"></i>
      </a>
  </div>
</nav>
</div> <!-- /content -->




</body></html>